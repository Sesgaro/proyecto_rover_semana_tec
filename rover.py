# -*- coding: utf-8 -*-
"""Rover.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1NPZtAo0_6_YpeLSZt4w1yuqq9zFU5loL
"""

import cv2
import numpy as np
import matplotlib.pyplot as plt
from random import randint

# Configuracion de colores (HSV)
RANGOS_COLORES = {
    "ROJO": [
        (np.array([0, 100, 50]), np.array([10, 255, 255])),
        (np.array([170, 100, 30]), np.array([179, 255, 255]))
    ],
    "VERDE": [
        (np.array([35, 40, 50]), np.array([75, 255, 255]))
    ],
    "AZUL": [
        (np.array([100, 100, 50]), np.array([140, 255, 255]))
    ]
}


# Cargar imagen

img = cv2.imread('piedras.jpg')

if img is None:
    print(f"Error: No se pudo cargar la imagen")
    exit()

img_hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)
img_resultado = img.copy()
resultados_deteccion = []
kernel = np.ones((5, 5), np.uint8)

# Deteccion de las piedras

for nombre_color, rangos in RANGOS_COLORES.items():
    mascara_color_actual = np.zeros_like(img_hsv[:, :, 0])

    for bajo, alto in rangos:
        mascara_parcial = cv2.inRange(img_hsv, bajo, alto)
        mascara_color_actual = cv2.bitwise_or(mascara_color_actual, mascara_parcial)

    mascara_dilatada = cv2.dilate(mascara_color_actual, kernel, iterations=2)
    contornos, _ = cv2.findContours(mascara_dilatada, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    for c in contornos:
        area = cv2.contourArea(c)
        if area > 500:
            M = cv2.moments(c)
            if M["m00"] != 0:
                cX = int(M["m10"] / M["m00"])
                cY = int(M["m01"] / M["m00"])

                # Evitar duplicados cercanos
                es_duplicado = False
                for res in resultados_deteccion:
                    dx = abs(res['coordenada'][0] - cX)
                    dy = abs(res['coordenada'][1] - cY)
                    if dx < 10 and dy < 10:
                        es_duplicado = True
                        break

                if not es_duplicado:
                    profundidad = randint(0, 30)  # Profundidad simulada
                    resultados_deteccion.append({
                        "color": nombre_color,
                        "coordenada": (cX, cY),
                        "area": area,
                        "profundidad": profundidad
                    })

# Ordenamiento por profundidad

if resultados_deteccion:
    resultados_deteccion.sort(key=lambda x: x["profundidad"])

    # Dimensiones de la imagen
    h, w = img.shape[:2]

    # Entrada y salida
    entrada_x = w // 2
    entrada_y = h - 30  # 30 píxeles desde el fondo
    punto_entrada = (entrada_x, entrada_y)

    salida_x = w // 2
    salida_y = 30  # 30 píxeles desde arriba
    punto_salida = (salida_x, salida_y)

    # Construccion de la ruta
    ruta_completa = [punto_entrada]
    for res in resultados_deteccion:
        ruta_completa.append(res["coordenada"])
    ruta_completa.append(punto_salida)

    # Dibujo
    for res in resultados_deteccion:
        cX, cY = res["coordenada"]
        # Contorno cian
        mascara_contorno = np.zeros_like(img_hsv[:, :, 0])
        for bajo, alto in RANGOS_COLORES[res["color"]]:
            mascara_contorno_parcial = cv2.inRange(img_hsv, bajo, alto)
            mascara_contorno = cv2.bitwise_or(mascara_contorno, mascara_contorno_parcial)

        contornos_dibujo, _ = cv2.findContours(mascara_contorno, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        cv2.drawContours(img_resultado, contornos_dibujo, -1, (255, 255, 0), 3)

        # Centro rojo
        cv2.circle(img_resultado, (cX, cY), 7, (0, 0, 255), -1)

    # Dibbujo de la ruta
    colores_ruta = [(0, 255, 0), (0, 255, 255), (255, 0, 255), (255, 165, 0), (0, 165, 255)]
    for i in range(len(ruta_completa) - 1):
        pt1 = ruta_completa[i]
        pt2 = ruta_completa[i + 1]
        color = colores_ruta[i % len(colores_ruta)]
        cv2.line(img_resultado, pt1, pt2, color, 3)
        cv2.arrowedLine(img_resultado, pt1, pt2, color, 3, tipLength=0.25)

    # Entrada
    cv2.circle(img_resultado, punto_entrada, 15, (100, 100, 255), -1)
    cv2.putText(img_resultado, "ENTRADA", (punto_entrada[0] - 55, punto_entrada[1] - 35),
                cv2.FONT_HERSHEY_DUPLEX, 0.9, (0, 0, 0), 6)
    cv2.putText(img_resultado, "ENTRADA", (punto_entrada[0] - 55, punto_entrada[1] - 35),
                cv2.FONT_HERSHEY_DUPLEX, 0.9, (255, 255, 255), 2)

    # Salida
    cv2.circle(img_resultado, punto_salida, 15, (100, 255, 100), -1)
    cv2.putText(img_resultado, "SALIDA", (punto_salida[0] - 50, punto_salida[1] + 55),
                cv2.FONT_HERSHEY_DUPLEX, 0.9, (0, 0, 0), 6)
    cv2.putText(img_resultado, "SALIDA", (punto_salida[0] - 50, punto_salida[1] + 55),
                cv2.FONT_HERSHEY_DUPLEX, 0.9, (0, 255, 0), 2)

    for idx, res in enumerate(resultados_deteccion, start=1):
        x, y = res["coordenada"]
        profundidad = res["profundidad"]

        # Numero de orden
        cv2.putText(img_resultado, f"{idx}", (x - 20, y - 20),
                    cv2.FONT_HERSHEY_SIMPLEX, 0.9, (0, 0, 0), 6)
        cv2.putText(img_resultado, f"{idx}", (x - 20, y - 20),
                    cv2.FONT_HERSHEY_SIMPLEX, 0.9, (255, 255, 0), 2)

        # Profundidad
        cv2.putText(img_resultado, f"{profundidad}cm", (x - 40, y + 35),
                    cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0, 0, 0), 4)
        cv2.putText(img_resultado, f"{profundidad}cm", (x - 40, y + 35),
                    cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 255, 255), 1)

    # Resultasdos

    print("\n" + "="*90)
    print(f"{'Paso':<6} | {'Tipo':<12} | {'X':<6} | {'Y':<6} | {'Profundidad':<12} | {'Acción'}")
    print("="*90)

    # Piedras
    for idx, res in enumerate(resultados_deteccion, start=1):
        x, y = res["coordenada"]
        print(f"{idx:<6} | {'PIEDRA':<12} | {x:<6} | {y:<6} | {res['profundidad']:<5} cm     | {f'Inspeccionar ({res['color']})'}")

    total_pasos = len(resultados_deteccion) + 2

    print(f"\nRuta óptima: FONDO → " + " → ".join([f"P{i+1} ({r['profundidad']}cm)" for i, r in enumerate(resultados_deteccion)]) + " → SUPERFICIE")

else:
    print("No se detectó ninguna piedra de color Rojo, Verde o Azul con el tamaño especificado.")

img_rgb = cv2.cvtColor(img_resultado, cv2.COLOR_BGR2RGB)
plt.figure(figsize=(16, 10))
plt.imshow(img_rgb)
plt.axis('off')

plt.show()